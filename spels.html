<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd"> 
<html> 
  <head> 
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> 
    <link rel="stylesheet" type="text/css" href="css/style.css"> 
    <link href="css/prettify.css" type="text/css" rel="stylesheet"> 
    <script type="text/javascript" src="js/prettify.js"></script> 
    <script type="text/javascript" src="js/lang-clojure.js"></script> 
    <title>Волшебство и Магия Clojure: Заклинания-спеллы</title> 
  </head> 
  <body onLoad="prettyPrint()"> 
    <div class="main"> 
      <div class="top"> 
        <span class="pager"><a href="index.html">&lt;&lt; первая</a></span> 
        <span class="pager"><a href="walking.html">&lt; назад</a></span> 
        <span class="pager"><a href="index.html">1</a></span> 
        <span class="pager"><a href="syntax.html">2</a></span> 
        <span class="pager"><a href="data.html">3</a></span> 
        <span class="pager"><a href="looking.html">4</a></span> 
        <span class="pager"><a href="walking.html">5</a></span> 
        <span class="pager current">6</span> 
        <span class="pager"><a href="actions.html">7</a></span> 
        <span class="pager"><a href="addendum.html">8</a></span> 
        <span class="pager"><a href="no_macros.html">9</a></span> 
        <span class="pager"><a href="actions.html">вперед &gt;</a></span> 
        <span class="pager"><a href="no_macros.html">последняя &gt;&gt;</a></span> 
        <span class="pagertext">Заклинания-спеллы...</span> 
      </div> 
      <div class="heading">Колдуем заклинания-спеллы</div> 
      <div class="textblock"> 
        <p> Сейчас мы собираемся узнать о невероятно мощной возможности Lisp-а: создании спеллов!
        </p> 
        <p> Спелл происходит от английского SPEL которое расшифровывается как "Semantic Program Enhancement Logic", то
	  есть "Логика Улучшения Семантической Программы". Здесь есть еще игра слов - SPEL это урезанная версия слова
	  SPELL, что означает в переводе "заклинание". Лисперы верят, что программа - это способ подчинить дух
	  компьютера и заставить его выполнять определенные действия, поэтому спелл будет более подходящим вариантом
	  перевода. Спеллы позволяют нам создавать новое поведение внутри мира нашего компьютера, которое изменяет сам
	  язык Lisp на фундаментальном уровне, позволяя делать то, что нам требуется - именно здесь Lisp больше всего
	  похож на магию. Чтобы использовать спеллы, мы должны сначала активировать их внутри нашего Lisp компилятора:
	  (не беспокойтесь о том, что эта строчка кода делает, а продвинутые лисперы должны
	  нажать <a href="no_macros.html">сюда.</a>)
        </p> 
        <pre class="prettyprint lang-clojure">(defmacro defspel [& rest] `(defmacro ~@rest))</pre> 
        <p> 
        Хорошо, теперь когда они включены, давайте создадим наш первый спелл, называемый <code>walk</code>:
        </p> 
        <pre class="prettyprint lang-clojure">(defspel walk [direction] `(walk-direction '~direction))</pre> 
        <p> Это код говорит компилятору Lisp что слово <code>walk</code> на самом деле не слово <code>walk</code>, а
        слово <code>walk-direction</code> вместе со словом <code>direction</code>, перед которым добавлена одинарная
        кавычка, хотя мы этого и не можем увидеть. По существу, мы можем вставить некий особый код внутри нашей
        программы и компилятор заменит наш код на что-то другое, прежде чем он начнет компилировать:
        </p> 
      </div> 
      <img src="images/spel_compile.jpg" alt="Compiling a SPEL"> 
      <div class="textblock"> 
        <p> Обратите внимание как эта функция похожа на тот код, который мы написали ранее для describe-path: В Lisp, не
         только код и данные выглядят очень похоже, но и код и специальные команды комилятору (спеллы) выглядят
         идентично - очень последовательная и ясная модель! Давайте попробуем наш новый спелл:
        </p> 
        <pre class="prettyprint lang-clojure">(walk east)</pre> 
        <pre class="console">
user=> (walk east)                                             
(you are in the living room of a wizards house -
there is a wizard snoring loudly on the couch -
there is a door going west from here -
there is a stairway going upstairs from here -
you see a whiskey-bottle on the floor -
you see a bucket on the floor -)</pre> 
        <p>Гораздо лучше!</p> 
        <p> Теперь мы создадим команду чтобы подбирать объекты в нашем мире:
        </p> 
        <pre class="prettyprint lang-clojure">
(defn pickup-object [object]
  (cond (is-at? object location object-locations)
        (do
          (def object-locations (assoc object-locations object 'body))
          `(you are now carrying the ~object))
        :else '(you cannot get that.)))</pre> 
        <p> Эта функция проверяет, действительно ли объект находится на земле в том месте, где мы сейчас находимся -
          если да, то она <i>проталкивает</i> новое место (body, тело игрока) в список (<i>проталкивать</i> означает
          добавить новый элемент в список таким образом, что команда <i>assoc</i> замечает это и прячет предыдущее
          место) и возвращает предложение, в котором говорится, удалось нам это или нет.
        </p> 
        <p> 
          Давайте теперь создадим очередный спелл, который позволит упростить команду:
        </p> 
        <pre class="prettyprint lang-clojure">(defspel pickup [object] `(spel-print (pickup-object '~object)))</pre> 
        <p> 
          Теперь попробуем наш новый спелл:
        </p> 
        <pre class="prettyprint lang-clojure">(pickup whiskey-bottle)</pre> 
      </div> 
      <div class="textblock"> 
        <pre class="console">user=> (pickup whiskey-bottle)
(you are now carrying the whiskey-bottle)</pre> 
        <p> Давайте теперь добавим еще пару полезных команд - сперва, команда, которая позволяет просматривать наш
          инвентарь, то, что мы несем с собой:
        </p> 
        <pre class="prettyprint lang-clojure">
(defn inventory []
  (filter (fn [x] (is-at? x 'body object-locations)) objects))</pre> 
        <p> 
          Теперь функцию, которая скажет нам, есть ли у нас некая вещь с собой:
        </p> 
        <pre class="prettyprint lang-clojure">
(defn have? [object]
   (some #{object} (inventory)))</pre> 
      </div> 
      <hr> 
      <div class="bottom"> 
        <span class="pager"><a href="index.html">&lt;&lt; первая</a></span> 
        <span class="pager"><a href="walking.html">&lt; назад</a></span> 
        <span class="pager"><a href="index.html">1</a></span> 
        <span class="pager"><a href="syntax.html">2</a></span> 
        <span class="pager"><a href="data.html">3</a></span> 
        <span class="pager"><a href="looking.html">4</a></span> 
        <span class="pager"><a href="walking.html">5</a></span> 
        <span class="pager current">6</span> 
        <span class="pager"><a href="actions.html">7</a></span> 
        <span class="pager"><a href="addendum.html">8</a></span> 
        <span class="pager"><a href="no_macros.html">9</a></span> 
        <span class="pager"><a href="actions.html">вперед &gt;</a></span> 
        <span class="pager"><a href="no_macros.html">последняя &gt;&gt;</a></span> 
        <span class="pagertext">Заклинания-спеллы...</span> 
      </div> 
    </div> 
  </body> 
</html> 
