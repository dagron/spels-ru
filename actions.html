<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd"> 
<html> 
  <head> 
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> 
    <link href="css/style.css" type="text/css" rel="stylesheet"> 
    <link href="css/prettify.css" type="text/css" rel="stylesheet"> 
    <script type="text/javascript" src="js/prettify.js"></script> 
    <script type="text/javascript" src="js/lang-clojure.js"></script> 
    <title>Волшебство и Магия Clojure: Определяем условия победы в игре</title> 
  </head> 
  <body onLoad="prettyPrint()"> 
    <div class="main"> 
      <div class="top"> 
        <span class="pager"><a href="index.html">&lt;&lt; первая</a></span> 
        <span class="pager"><a href="spels.html">&lt; назад</a></span> 
        <span class="pager"><a href="index.html">1</a></span> 
        <span class="pager"><a href="syntax.html">2</a></span> 
        <span class="pager"><a href="data.html">3</a></span> 
        <span class="pager"><a href="looking.html">4</a></span> 
        <span class="pager"><a href="walking.html">5</a></span> 
        <span class="pager"><a href="spels.html">6</a></span> 
        <span class="pager current">7</span> 
        <span class="pager"><a href="addendum.html">8</a></span> 
        <span class="pager"><a href="no_macros.html">9</a></span> 
        <span class="pager"><a href="addendum.html">вперед &gt;</a></span> 
        <span class="pager"><a href="no_macros.html">последняя &gt;&gt;</a></span> 
        <span class="pagertext">Определяем условия победы...</span> 
      </div> 
      <div class="heading">Определяем условия победы в нашей игре</div> 
      <div class="textblock"> 
        <p> Нам осталось сделать только одну вещь и наша игра будет закончена: добавить некоторые специальные действия в
	  игру, которые игрок должен будет выполнить, чтобы выиграть в игре. Первая команада позволит приварить цепь к
	  ведру на чердаке: 
        </p> 
        <pre class="prettyprint lang-clojure">
(def chain-welded false)
 
(defn weld [subject object]
  (cond (and (= location 'attic)
             (= subject 'chain)
             (= object 'bucket)
             (have? 'chain)
             (have? 'bucket)
             (not chain-welded))
        (do (def chain-welded true)
            '(the chain is now securely welded to the bucket -))
        :else '(you cannot weld like that -)))</pre> 
        <p> Сначала мы создаем глобальную переменную, которая будет хранить информацию, сделали ли мы уже это
        действие. Дальше, мы создадим функцию weld (приварить), которая проверит, что все условия выполняют и можно
        начать сваривать.
        </p> 
      </div> 
      <img src="images/weld.jpg" alt="Welding"> 
      <div class="textblock"> 
        <p> 
        Давайте попробуем нашу новую команду:
        </p> 
        <pre class="prettyprint lang-clojure">(weld 'chain 'bucket)</pre> 
        <pre class="console">user=> (weld 'chain 'bucket)
(you cannot weld like that -)</pre> 
        <p> 
          Ой... у нас нет ведра или цепи, не так ли? ... и поблизости нет сварочного аппарата ... ох, ладно ...
        </p> 
        <p> Давайте создадим команду для окунания ведра с цепью в колодец:
        </p> 
        <pre class="prettyprint lang-clojure">(def bucket-filled false)
 
(defn dunk [subject object]
  (cond (and (= location 'garden)
             (= subject 'bucket)
             (= object 'well)
             (have? 'bucket)
             chain-welded)
        (do (def bucket-filled true)
            '(the bucket is now full of water))
        :else '(you cannot dunk like that -)))</pre> 
        <p> Если вы были внимательны, то возможно заметили, что команда выглядит <i>очень</i> похоже на код
        команды <code>weld</code>... Обе команды должны проверить место, субъект и объект - но при этом достаточно
        различий, чтобы мы не смогли объединить сходства в единую функцию. Очень жаль...
        </p> 
        <p> ...но так как это Lisp, то мы можем делать больше, чем просто писать функции, мы может создавать спеллы!
        Давайте создаим следующий спелл:
        </p> 
        <pre class="prettyprint lang-clojure">
(defspel game-action [command subj obj place & args]
  `(defspel ~command [subject# object#]
     `(spel-print (cond (and (= location '~'~place)
                             (= '~subject# '~'~subj)
                             (= '~object# '~'~obj)
                             (have? '~'~subj))
                        ~@'~args
                        :else '(i cannot ~'~command like that -)))))</pre> 
      </div> 
      <div class="textblock"> 
        <p> Обратите внимание, насколько нелепо и сложно выглядит этот спелл - в нем много таинственных одинарных
        кавычек, обратных кавычек, запятых и других странных символов. Более того, этот спелл вызывает ДРУГОЙ СПЕЛЛ!
        Даже опытные Lisp программисты должны были бы немного подумать, чтобы создать такое чудовище (и на самом деле
        они сочли бы этот спелл неэлегантым, сделали бы пассы руками и приняли бы несколько нетривиальных решений, чтобы
        сделать его более приглядным, то есть то, что мы не будем делать здесь...)
        </p> 
      </div> 
      <img src="images/game_action.jpg" alt="Game Action"> 
      <div class="textblock"> 
        <p> Идея этого спелла заключается в том, чтобы показать насколько изысканно и умно можно подойти к использованию
        спеллов. Также, бозобразность на самом деле не играет особого значения, если благодаря этому мы сможем написать
        сотни команд для большой приключенческой игры.
        </p> 
        <p> Давайте используем наш навый спелл, чтобы заменить безобразную команду <code>weld</code>:
        </p> 
        <pre class="prettyprint lang-clojure">(game-action weld chain bucket attic
   (cond (and (have? 'bucket) (def chain-welded true))
              '(the chain is now securely welded to the bucket -)
         :else '(you do not have a bucket -)))</pre> 
        <p> Посмотри насколько понятнее стала команда - спелл <code>game-action</code> позволяет нам писать именно то,
        что мы ходим сказать, без шелухи - это выглядит почти так, как будто мы создали свой собственный компьютерный
        язык для создания игровых команд. Такой созданный при помощи спеллов псевдо-язык
        называется <b>предметно-ориентированным языком программирования</b> и использование такого языка - очень мощный
        способ программировать быстро и элегантно.
        </p> 
        <pre class="prettyprint lang-clojure">(weld chain bucket)</pre> 
        <pre class="console">user=> (weld chain bucket)
(you do not have a chain -)</pre> 
        <p> ...мы все еще не можем ничего приварить, но команда делает свое дело!
        </p> 
      </div> 
      <img src="images/dunk.jpg" alt="Dunking"> 
      <div class="textblock"> 
        <p> 
        Теперь, давайте перепишем команду <code>dunk</code>:
        </p> 
        <pre class="prettyprint lang-clojure">
(game-action dunk bucket well garden
             (cond chain-welded 
                   (do (def bucket-filled true)
                       '(the bucket is now full of water))
                   :else '(the water level is too low to reach -)))</pre> 
        <p> Обратите внимание, как команда <code>weld</code> проверяет, есть ли у нас субъект с
        помощью <code>have?</code>, а команда dunk пропускает этот шаг - наш новый спелл game-action делает код более
        простым для написания и чтения.
        </p> 
      </div> 
      <img src="images/splash.jpg" alt="Splash"> 
      <div class="textblock"> 
        <p> 
          Теперь наша последняя часть кода для плескания воды в волшебника:
        </p> 
        <pre class="prettyprint lang-clojure">
(game-action splash bucket wizard living-room
             (cond (not bucket-filled) '(the bucket has nothing in it -)
                   (have? 'frog) '(the wizard awakens and sees that you stole
                                       his frog -
                                       he is so upset he banishes you to the
                                       netherworlds - you lose! the end -)
                   :else '(the wizard awakens from his slumber and greets you
                               warmly -
                               he hands you the magic low-carb donut - you win!
                               the end -)))</pre> 
      </div> 
      <img src="images/donut.jpg" alt="Getting the Donut"> 
      <div class="textblock"> 
        <p> 
        <b>Теперь у вас есть готовая текстовая приключенческая игра!</b> 
        </p> 
        <p> Нажмите <a href="cheat.html">СЮДА</a> чтобы посмотреть прохождение игры,
        </p> 
        <p> Нажмите <a href="code.html">СЮДА</a> для получения копии исходного кода, который вы можете выделить и
          скопировать в консоль Clojure за один раз.
        </p> 
        <p> Чтобы сделать это руководство настолько простым, насколько возможно, многие детали как Lisp работает были
        умолчаны или упрощены, поэтому давайте посмотрим, что же это были за детали ....
        </p> 
      </div> 
      <hr> 
      <div class="bottom"> 
        <span class="pager"><a href="index.html">&lt;&lt; первая</a></span> 
        <span class="pager"><a href="spels.html">&lt; назад</a></span> 
        <span class="pager"><a href="index.html">1</a></span> 
        <span class="pager"><a href="syntax.html">2</a></span> 
        <span class="pager"><a href="data.html">3</a></span> 
        <span class="pager"><a href="looking.html">4</a></span> 
        <span class="pager"><a href="walking.html">5</a></span> 
        <span class="pager"><a href="spels.html">6</a></span> 
        <span class="pager current">7</span> 
        <span class="pager"><a href="addendum.html">8</a></span> 
        <span class="pager"><a href="no_macros.html">9</a></span> 
        <span class="pager"><a href="addendum.html">вперед &gt;</a></span> 
        <span class="pager"><a href="no_macros.html">последняя &gt;&gt;</a></span> 
        <span class="pagertext">Определяем условия победы...</span> 
      </div> 
    </div> 
  </body> 
</html> 
